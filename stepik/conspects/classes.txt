 Классы:

- class MyClass:  - пустой класс
    pass

- x = MyClass() - конструктор класса (по-умолчанию)

- def __init__(self, ...): - инициализированный конструктор, который добавляет новые поля в nameSpace
    self.a = 10

- x.count = 0 - добавление поля в ЭКЗЕМПЛЯР данного класса

- поля !=> конструктору становятся ЕДИНЫМИ для ВСЕХ ЭКЗЕМПЛЯРОВ. Т.е изменив поле в одном экземпляре,оно изменится и в другом

- ВСЕ ПОЛЯ ВНУТРИ КОНСТРУКТОРА!!

- ПРИМЕР:
    class Song:
        def __init__(self, song, artist):
            self.song = song
            self.artist = artist
            self.tags = []

        def add_tags(self, *tags):
            self.tags.extend(tags)



 Наследование:

- class MyClass(list, ....):  - в скобках указываются родительские классы (возможно МНОЖЕСТВЕННОЕ наследование)
    def even_len(self):
        return len(self) % 2 == 0  - использование метода другого класса по отношению к себе

- при наследовании :
    * сохраняется конструктор родителя (если мы не указали свой)
    * сохраняются все методы родительского класса (внутри вызываются как super(MyClass, self).append(x))
    * сохраняются все реализации вывода (__str__ например), которые могут быть переопределены
    * при переопределении метода для класса-наследника, этот же метод переопределяется, если он где-либо использовался у родителя внутри

- все классы наследуются от Object по-умолчанию

- issubclass(A, B) -> True/False - проверка является ли А наследником B (важен порядок указания аргументов)
- isinstance(A, B) -> True/False - можем ли мы использовать объект A в кач-ве объекта В



 Множественное наследование:

- MyClass.mro() - выводит порядок поиска родительских методов/конструкторов (соответсвует порядку указания в скобках)