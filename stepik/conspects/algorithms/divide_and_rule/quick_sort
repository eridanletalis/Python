 Быстрая сортировка:

ВХОД: массив A[1...n]
ВЫХОД: отсортированный массив A[1...n]
ИДЕЯ:
- разбить массив на 3 части ([] <= x < [])
- затем для каждой из частей сделать то же самое
- x - опорный элемент, выбирается A[0] и вычисляется его месторасположение, при этом часть элементов меняются местами
РЕАЛИЗАЦИЯ:
 * функция обмена элементов вокруг опорного:
    def partition(A, a, b):
        x = A[a]
        j = a
        for i in range(j+1, b+1):          - запускаем цикл до конца массива
            if A[i] <= x:                  - если след. элемент больше x, тогда увеличиваем min зону на 1 и меняем местами
                j += 1
                c = A[i]
                A[i] = A[j]
                A[j] = c
        c = A[a]                           - меняем местами x и последний элемент min зоны
        A[a] = A[j]
        A[j] = c
        return j


    def quick_sort(A, a, b):
        while a < b:
            m = partition(A, a, b)
            if (m-1) - a > b - (m+1):      - элиминируем 2-ой рекурсивный вызов, чтобы макс. глубина рекурсии была O(log(n))
                quick_sort(A, m+1, b)
                b = m - 1
            else:
                quick_sort(A, a, m-1)
                a = m + 1
