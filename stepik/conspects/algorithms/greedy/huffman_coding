 Коды Хаффмана:

 Первая формулировка:

ВХОД: строка s
ВЫХОД: бинарный код символов строки s, обеспечивающий кратчайшее представление
ИДЕЯ:
- безпрефиксный код(ни один код не является префиксом другого кода) НАПРИМЕР: 'a'->0, 'b'->10, 'c'->110
- безпрефиксный код образует двоичное дерево(у элементов либо 0, либо 2 ребенка)

 Вторая формулировка:

ВХОД: частоты символов f1...fN (как часто встречается символ)
ВЫХОД: строго двоичное дерево, листья которого помечены частотами f1...fN, которое минимизирует sum(f1...fN * глубину fI)
ИДЕЯ:
- ищем дерево с min sum(пометок), где для листьев: пометка - входные частоты, для вн.вершин: пометка - sum пометок их детей
- двумя наименьшими частотами помечены два листа на нижнем уровне
- надёжный жадный шаг:
    * выбрать две min частоты fI и fJ
    * сделать их детьми новой вершины с пометкой fI + fJ
    * выкинуть частоты fI и fJ, и добавить частоту fI + fJ
- продолжаем для оставшихся f делать шаги (т.е к fI + fJ добавляем наименьшего "брата") пока вершин не останется
РЕАЛИЗАЦИЯ:
H = []                        - (очередь с приоритетами)
for i in range(n):            - перебор символов
    H.insert(i, f(i))         - вставляем пару (символ, частота символа)
for k in range(n+1, 2*n-1):   - перебор внутренних вершин для замены
    a = H.extract_min()       - достаем первый символ с min частотой
    b = H.extract_min()       - достаем второй символ с min частотой
    f(k) = f(a) + f(b)        - частоту родителя вычисляем как сумму частот детей
    H.insert(k, f(k))         - вставляем полученную вершину