 Расстояние редактирования:

ВХОД: строки A[1...n] и B[1...m]
ВЫХОД: min кол-во вставок, удалений и замен символов, необходимое для преобразования A в B. (Данное число называется расстоянием редактирования и расстоянием Левенштейна)
ИДЕЯ:
- выравнивание (изменение массивов таким образом, чтобы длина их была равна и было max кол-во совпадений, т.е A[i] == B[i]):
    * рассмотрим вариации последнего столбца оптимального выравнивания:
        * вставка ( нет символа A, но есть символ B)
        * удаление ( есть символ A, но нет символа B)
        * (не)соответствие ( есть символы A и B, но они разные/одинаковые)
    * префикс до последнего столбца обязан быть оптимальным
    * берем последний столбец префикса и наблюдаем ту же картину
    * тогда выделим подзадачи:
        * пусть D[i][j] - расстояние редактирования строк (для A[1...i] и B[1...j])
        * последний столбец соответсвенно - вставка/удаление/(не)соответсвие
        * выравнивание без последнего столбца оптимально
        * тогда получаем выражение:
            D[i][j] = min { D[i, j - 1] + 1,                     - вставка
                            D[i - 1, j] + 1,                     - удаление
                            D[i - 1, j - 1] + diff(A[i], B[j]) } - (не)соответсвие (diff - меняет одно из знач., если они разные)
РЕАЛИЗАЦИЯ(1)(нахождение min кол-ва вставок):
    d = [[inf] * m] * n

    def diff(a, b):
        if a == b:
            return 0
        else:
            return 1

    def edit_dist(i, j, d):
        if d[i][j] == inf:
            if i == 0:
                d[i][j] = j
            elif j == 0:
                d[i][j] = i
            else:
                ins = edit_dist(i, j - 1) + 1
                del = edit_dist(i - 1, j) + 1
                sub = edit_dist(i - 1, j - 1) + diff(a[i], b[j])
                d[i][j] = min(ins, del, sub)
        return d[i][j]

СЛОЖНОСТЬ:
- O(n * m)


РЕАЛИЗАЦИЯ(2)(нахождение min кол-ва вставок):

    def diff(a, b):
        if a == b:
            return 0
        else:
            return 1

    def edit_dist(a[1...n], b[1...m]):
        d = [[0] * (m+1)] * (n+1)
        for i in range(n + 1):
            d[i][0] = i
        for j in range(m + 1):
            d[0][j] = j
        for i in range(1, n+1):
            for j in range(1, m+1):
                c = diff(a[i - 1], b[j - 1])
                d[i][j] = min(d[i - 1][j] + 1,
                              d[i][j - 1] + 1,
                              d[i - 1][j - 1] + c)
        return d[n][m]

СЛОЖНОСТЬ:
- O(n * m)

ДОПОЛНЕНИЕ(восстановление ответа):

    def diff(a, b):
        if a == b:
            return 0
        else:
            return 1


    def edit_dist(a[1...n], b[1...m]):
        d = [[0] * (m+1)] * (n+1)
        for i in range(n + 1):
            d[i][0] = i
        for j in range(m + 1):
            d[0][j] = j
        for i in range(1, n+1):
            for j in range(1, m+1):
                c = diff(a[i - 1], b[j - 1])
                d[i][j] = min(d[i - 1][j] + 1,
                              d[i][j - 1] + 1,
                              d[i - 1][j - 1] + c)
        i = n + 1
        j = m + 1
        res = []
        while i != 0 or j != 0:
            if d[i][j] == d[i - 1][j - 1] + diff(a[i - 1], b[j - 1]):
                res.append([a[i - 1], b[j - 1]])
                i -= 1
                j -= 1
            if d[i][j] == d[i - 1][j] + 1:
                res.append([a[i - 1], '-'])
                i -= 1
            if d[i][j] == d[i][j - 1] + 1:
                res.append(['-', b[j - 1]])
                j -= 1
        return res

