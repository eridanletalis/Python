 Доступ данных к структурам Pandas:

- использование меток:
    * если обращаться к отсутствующей метке, то будет выброшено KeyError
    * в этом случае работа ведется через метод .loc
    * такой подход позволяет использовать:
         # метки в виде отдельных символов [‘a’] или чисел [5] (числа используются в качестве меток, если др. метки не были указаны)
         # список меток [‘a’, ‘b’, ‘c’]
         # слайс меток [‘a’:’c’]
         # массив логических переменных
         # callable функция с одним аргументом (lambda)

- использование целых чисел:
    * если обращаться к несуществующему элементу, то будет выброшено IndexError
    * в этом случае работа ведется через метод .iloc
    * при таком подходе можно использовать:
        # отдельные целые числа для доступа к элементам структуры
        # массивы целых чисел [0, 1, 2]
        # слайсы целых чисел [1:4]
        # массивы логических переменных
        # callable функцию с одним аргументом (lambda)

- примеры доступа к данным в Series:
    * s['a']              - доступ по метке
    * s[['a', 'c', 'e']]  - получение элементов с метками из массива
    * s['a':'e']          - получение элементов через слайс
    * s[lambda x: x>= 30] - получение элементов через callable-функцию (в примере - все элементы >= 30)
    * s[s > 30]           - получение элементов по логическому выражению (в примере - все элементы > 30)

- примеры доступа к данным в DataFrame:
    * df['count']                    - все элементы столбца с меткой
    * df[['count','price']]          - все элементы двух столбцов по метке
    * df['a':'b']                    - получение всех элементов в диапазоне слайса
    * df[lambda x: x['count'] > 15]  - доступ к элементам через callable-функцию (в примере все элементы(строки), которые в столбце по метке > 15)
    * df[df['price'] >= 2]           - доступ по логическому выражению (в примере все строки, в которых элементы столбца по метке >= 2)

- использование атрибутов(атрибуты - метки):
    * s.a       - доступ по атрибуту (в Series)
    * df.price  - доступ к столбцу по атрибуту (в DataFrame)

- получение случайного набора элементов из структуры:
    * для Series:
        # s.sample()                                          - случайный элемент
        # s.sample(n=3)                                       - 3 случайных элемента
        # s.sample(frac=0.3)                                  - 30% от всего размера случайных элементов
        # s.sample(n = 3, weights=[0.1, 0.2, 0.5, 0.1, 0.1])  - w - вектор весов(sum(wI) == 1, len(w) = len(s))
    * для DataFrame:
        # df.sample()                 - случайная строка
        # df.sample(n=3)              - 3 случайные строки
        # df.sample(frac=0,3)         - 30% от всего размера случайных строк
        # df.sample(n=3, weights=w)   - 3 случайных элемента с указанием весов
        # df.sample(n=2, axis=1)      - 2 случайных столбца

- добавление нового элемента:
    * s['new']                     - для Series (новая метка, как в словаре)
    * df['new'] = [1, 2, 3, 4, 5]  - для DataFrame (добавление нового столбца по новой метке с таким же кол-вом элементов)

- использование callable-функции:
    * df[df["cat"].map(lambda x: x == "A")] - можно использовать сложные сочетания(map, filter, sort)

- использование .isin:
    * s.isin([10, 20]) - возвращает массив [True/False], где для каждого элемента - bool значение соответсвия (для Series)
    * df.isin([1, 3, 25, 30, 10]) - возвращает таблицу [True/False], где для каждого элемента - bool значение соответсвия (для DataFrame)

